<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Morten&#39;s Blog</title>
  
  <subtitle>Quick notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://limaomei1986.github.io/"/>
  <updated>2017-09-28T02:13:48.000Z</updated>
  <id>https://limaomei1986.github.io/</id>
  
  <author>
    <name>Morten</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发 - CountDownLatch示例</title>
    <link href="https://limaomei1986.github.io/2017/09/27/Java%E5%B9%B6%E5%8F%91-CountDownLatch%E7%A4%BA%E4%BE%8B/"/>
    <id>https://limaomei1986.github.io/2017/09/27/Java并发-CountDownLatch示例/</id>
    <published>2017-09-27T07:40:30.000Z</published>
    <updated>2017-09-28T02:13:48.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;CountDownLatch&lt;/strong&gt;是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。在Java并发中，countdownlatch的概念是一个常见的面试题，所以一定要确保你很好的理解了它。在这篇文章中，将会涉及到在Java并发编程中跟CountDownLatch相关的以下几点：&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;CountDownLatch是什么？&lt;/li&gt;
&lt;li&gt;CountDownLatch如何工作？&lt;/li&gt;
&lt;li&gt;在实时系统中的应用场景&lt;/li&gt;
&lt;li&gt;应用范例&lt;/li&gt;
&lt;li&gt;常见的面试题&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;CountDownLatch是什么&quot;&gt;&lt;a href=&quot;#CountDownLatch是什么&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch是什么&quot;&gt;&lt;/a&gt;CountDownLatch是什么&lt;/h2&gt;&lt;p&gt;CountDownLatch是在Java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。&lt;br&gt;CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，&amp;gt;然后在闭锁上等待的线程就可以恢复执行任务。&lt;br&gt;
    
    </summary>
    
      <category term="Core Java" scheme="https://limaomei1986.github.io/categories/Core-Java/"/>
    
    
      <category term="Java" scheme="https://limaomei1986.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://limaomei1986.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之CountDownLatch、CyclicBarrier和Semaphore</title>
    <link href="https://limaomei1986.github.io/2017/09/27/Java%E5%B9%B6%E5%8F%91%E4%B9%8BCountDownLatch%E3%80%81CyclicBarrier%E5%92%8CSemaphore/"/>
    <id>https://limaomei1986.github.io/2017/09/27/Java并发之CountDownLatch、CyclicBarrier和Semaphore/</id>
    <published>2017-09-27T05:29:05.000Z</published>
    <updated>2017-09-28T02:52:03.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;CountDownLatch 是能使一组线程等另一组线程都跑完了再继续跑；CyclicBarrier 能够使一组线程在一个时间点上达到同步，可以是一起开始执行全部任务或者一部分任务。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这次说一下 JUC 中的同步器三个主要的成员：CountDownLatch、CyclicBarrier 和 Semaphore（不知道有没有初学者觉得这三个的名字不太好记）。这三个是 JUC 中较为常用的同步器，通过它们可以方便地实现很多线程之间协作的功能。（下面的代码出自 JDK 文档）&lt;/p&gt;
&lt;h2 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h2&gt;&lt;p&gt;直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。&lt;/p&gt;
&lt;h3 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h3&gt;&lt;p&gt;CountDownLatch 的作用和 Thread.join() 方法类似，可用于一组线程和另外一组线程的协作。例如，主线程在做一项工作之前需要一系列的准备工作，只有这些准备工作都完成，主线程才能继续它的工作。这些准备工作彼此独立，所以可以并发执行以提高速度。在这个场景下就可以使用 CountDownLatch 协调线程之间的调度了。在直接创建线程的年代（Java 5.0 之前），我们可以使用 Thread.join()。在 JUC 出现后，因为线程池中的线程不能直接被引用，所以就必须使用 CountDownLatch 了。&lt;br&gt;
    
    </summary>
    
      <category term="Core Java" scheme="https://limaomei1986.github.io/categories/Core-Java/"/>
    
    
      <category term="Java" scheme="https://limaomei1986.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://limaomei1986.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
