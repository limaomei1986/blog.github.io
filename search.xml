<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java并发 - CountDownLatch示例]]></title>
    <url>%2F2017%2F09%2F27%2FJava%E5%B9%B6%E5%8F%91-CountDownLatch%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。在Java并发中，countdownlatch的概念是一个常见的面试题，所以一定要确保你很好的理解了它。在这篇文章中，将会涉及到在Java并发编程中跟CountDownLatch相关的以下几点： 目录 CountDownLatch是什么？ CountDownLatch如何工作？ 在实时系统中的应用场景 应用范例 常见的面试题 CountDownLatch是什么CountDownLatch是在Java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，&gt;然后在闭锁上等待的线程就可以恢复执行任务。 CountDownLatch如何工作CountDownLatch.java类中定义的构造函数：12//Constructs a CountDownLatch initialized with the given count.public void CountDownLatch(int count) &#123;...&#125; 构造器中的计数值（count）实际上就是闭锁需要等待的线程数量。这个值只能被设置一次，而且CountDownLatch没有提供任何机制去重新设置这个计数值。与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await()方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成&gt;各自的任务。其他N 个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过CountDownLatch.countDown()方法来完成的；每调用一次这个方&gt;法，在构造函数中初始化的count值就减1。所以当N个线程都调 用了这个方法，count的值等于0，然后主线程就能通过await()方法，恢复执行自己的任务。 在实时系统中的使用场景让我们尝试罗列出在java实时系统中CountDownLatch都有哪些使用场景。我所罗列的都是我所能想到的。如果你有别的可能的使用方法，请在留言里列出来，这样会帮助到大家。 实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等&gt;待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。 开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了。 死锁检测：一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。 CountDownLatch使用例子在这个例子中，我模拟了一个应用程序启动类，它开始时启动了n个线程类，这些线程将检查外部系统并通知闭锁，并且启动类一直在闭锁上等待着。一旦验证和检查了所有外部服务，那么启动类恢复执行。BaseHealthChecker.java：这个类是一个Runnable，负责所有特定的外部服务健康的检测。它删除了重复的代码和闭锁的中心控制代码。12345678910111213141516171819202122232425262728293031323334public abstract class BaseHealthChecker implements Runnable &#123; private CountDownLatch _latch; private String _serviceName; private boolean _serviceUp; //Get latch object in constructor so that after completing the task, thread can countDown() the latch public BaseHealthChecker(String serviceName, CountDownLatch latch) &#123; super(); this._latch = latch; this._serviceName = serviceName; this._serviceUp = false; &#125; @Override public void run() &#123; try &#123; verifyService(); _serviceUp = true; &#125; catch (Throwable t) &#123; t.printStackTrace(System.err); _serviceUp = false; &#125; finally &#123; if(_latch != null) &#123; _latch.countDown(); &#125; &#125; &#125; public String getServiceName() &#123; return _serviceName; &#125; public boolean isServiceUp() &#123; return _serviceUp; &#125; //This methos needs to be implemented by all specific service checker public abstract void verifyService();&#125; NetworkHealthChecker.java：这个类继承了BaseHealthChecker，实现了verifyService()方法。DatabaseHealthChecker.java和CacheHealthChecker.java除了服务名和休眠时间外&gt;，与NetworkHealthChecker.java是一样的。123456789101112131415public class NetworkHealthChecker extends BaseHealthChecker &#123; public NetworkHealthChecker (CountDownLatch latch) &#123; super("Network Service", latch); &#125; @Override public void verifyService() &#123; System.out.println("Checking " + this.getServiceName()); try &#123; Thread.sleep(7000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(this.getServiceName() + " is UP"); &#125;&#125; ApplicationStartupUtil.java：这个类是一个主启动类，它负责初始化闭锁，然后等待，直到所有服务都被检测完。1234567891011121314151617181920212223242526272829303132333435363738394041public class ApplicationStartupUtil &#123; //List of service checkers private static List&lt;BaseHealthChecker&gt; _services; //This latch will be used to wait on private static CountDownLatch _latch; private ApplicationStartupUtil() &#123; &#125; private final static ApplicationStartupUtil INSTANCE = new ApplicationStartupUtil(); public static ApplicationStartupUtil getInstance() &#123; return INSTANCE; &#125; public static boolean checkExternalServices() throws Exception &#123; //Initialize the latch with number of service checkers _latch = new CountDownLatch(3); //All add checker in lists _services = new ArrayList&lt;BaseHealthChecker&gt;(); _services.add(new NetworkHealthChecker(_latch)); _services.add(new CacheHealthChecker(_latch)); _services.add(new DatabaseHealthChecker(_latch)); //Start service checkers using executor framework Executor executor = Executors.newFixedThreadPool(_services.size()); for(final BaseHealthChecker v : _services) &#123; executor.execute(v); &#125; //Now wait till all services are checked _latch.await(); //Services are file and now proceed startup for(final BaseHealthChecker v : _services) &#123; if( ! v.isServiceUp()) &#123; return false; &#125; &#125; return true; &#125;&#125; 现在你可以写测试代码去检测一下闭锁的功能了。1234567891011public class Main &#123; public static void main(String[] args) &#123; boolean result = false; try &#123; result = ApplicationStartupUtil.checkExternalServices(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("External services validation completed !! Result was :: "+ result); &#125;&#125; Output in console: Checking Network ServiceChecking Cache ServiceChecking Database ServiceDatabase Service is UPCache Service is UPNetwork Service is UPExternal services validation completed !! Result was :: true 常见面试题可以为你的下次面试准备以下一些CountDownLatch相关的问题： 解释一下CountDownLatch概念? CountDownLatch 和CyclicBarrier的不同之处? 给出一些CountDownLatch使用的例子? CountDownLatch 类中主要的方法? 原文链接： howtodoinjava 翻译： ImportNew.com - 张涛译文链接： http://www.importnew.com/15731.html]]></content>
      <categories>
        <category>Core Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发之CountDownLatch、CyclicBarrier和Semaphore]]></title>
    <url>%2F2017%2F09%2F27%2FJava%E5%B9%B6%E5%8F%91%E4%B9%8BCountDownLatch%E3%80%81CyclicBarrier%E5%92%8CSemaphore%2F</url>
    <content type="text"><![CDATA[CountDownLatch 是能使一组线程等另一组线程都跑完了再继续跑；CyclicBarrier 能够使一组线程在一个时间点上达到同步，可以是一起开始执行全部任务或者一部分任务。 这次说一下 JUC 中的同步器三个主要的成员：CountDownLatch、CyclicBarrier 和 Semaphore（不知道有没有初学者觉得这三个的名字不太好记）。这三个是 JUC 中较为常用的同步器，通过它们可以方便地实现很多线程之间协作的功能。（下面的代码出自 JDK 文档） CountDownLatch直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。 作用CountDownLatch 的作用和 Thread.join() 方法类似，可用于一组线程和另外一组线程的协作。例如，主线程在做一项工作之前需要一系列的准备工作，只有这些准备工作都完成，主线程才能继续它的工作。这些准备工作彼此独立，所以可以并发执行以提高速度。在这个场景下就可以使用 CountDownLatch 协调线程之间的调度了。在直接创建线程的年代（Java 5.0 之前），我们可以使用 Thread.join()。在 JUC 出现后，因为线程池中的线程不能直接被引用，所以就必须使用 CountDownLatch 了。 示例下面的这个例子可以理解为 F1 赛车的维修过程，只有 startSignal （可以表示停车，可能名字不太贴合）命令下达之后，维修工才开始干活，只有等所有工人完成工作之后，赛车才能继续。12345678910111213141516171819202122232425262728class Driver &#123; // ... void main() throws InterruptedException &#123; CountDownLatch startSignal = new CountDownLatch(1); CountDownLatch doneSignal = new CountDownLatch(N); for (int i = 0; i &lt; N; ++i) // create and start threads new Thread(new Worker(startSignal, doneSignal)).start(); doSomethingElse(); // don't let run yet startSignal.countDown(); // let all threads proceed doSomethingElse(); doneSignal.await(); // wait for all to finish &#125; &#125; class Worker implements Runnable &#123; private final CountDownLatch startSignal; private final CountDownLatch doneSignal; Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123; this.startSignal = startSignal; this.doneSignal = doneSignal; &#125; public void run() &#123; try &#123; startSignal.await(); doWork(); doneSignal.countDown(); &#125; catch (InterruptedException ex) &#123;&#125; // return; &#125; void doWork() &#123; ... &#125; &#125; 当 startSignal.await() 会阻塞线程，当 startSignal.countDown() 被调用之后，所有 Worker 线程开始执行 doWork() 方法，所以 Worker。doWork() 是几乎同时开始执行的。当 Worker.doWork() 执行完毕后，调用 doneSignal.countDown()，在所有 Worker 线程执行完毕之后，主线程继续执行。 CyclicBarrierCyclicBarrier 翻译过来叫循环栅栏、循环障碍什么的（还是有点别扭的。所以还是别翻译了，只可意会不可言传啊）。它主要的方法就是一个：await()。await() 方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。在这之后，如果再次调用 await() 方法，计数就又会变成 N-1，新一轮重新开始，这便是 Cyclic 的含义所在。CyclicBarrier 的使用并不难，但需要主要它所相关的异常。除了常见的异常，CyclicBarrier.await() 方法会抛出一个独有的 BrokenBarrierException。这个异常发生在当某个线程在等待本 CyclicBarrier 时被中断或超时或被重置时，其它同样在这个 CyclicBarrier 上等待的线程便会受到 BrokenBarrierException。意思就是说，同志们，别等了，有个小伙伴已经挂了，咱们如果继续等有可能会一直等下去，所有各回各家吧。CyclicBarrier.await() 方法带有返回值，用来表示当前线程是第几个到达这个 Barrier 的线程。和 CountDownLatch 一样，CyclicBarrier 同样可以可以在构造函数中设定总计数值。与 CountDownLatch 不同的是，CyclicBarrier 的构造函数还可以接受一个 Runnable，会在 CyclicBarrier 被释放时执行。 “NOTE: CyclicBarrier 的功能也可以由 CountDownLatch 来实现 示例CyclicBarrier 的应用（当然，这个例子换成 CountDownLatch 也是可以实现的，很简单，就不说怎么写了）12345678910111213141516171819202122232425262728293031323334class Solver &#123; final int N; final float[][] data; final CyclicBarrier barrier; class Worker implements Runnable &#123; int myRow; Worker(int row) &#123; myRow = row; &#125; public void run() &#123; while (!done()) &#123; processRow(myRow); try &#123; barrier.await(); &#125; catch (InterruptedException ex) &#123; return; &#125; catch (BrokenBarrierException ex) &#123; return; &#125; &#125; &#125; &#125; public Solver(float[][] matrix) &#123; data = matrix; N = matrix.length; barrier = new CyclicBarrier(N, new Runnable() &#123; public void run() &#123; mergeRows(...); &#125; &#125;); for (int i = 0; i &lt; N; ++i) new Thread(new Worker(i)).start(); waitUntilDone(); &#125; &#125; CyclicBarrier 和 CountDownLatch 在用法上的不同CountDownLatch 适用于一组线程和另一个主线程之间的工作协作。一个主线程等待一组工作线程的任务完毕才继续它的执行是使用 CountDownLatch 的主要场景；CyclicBarrier 用于一组或几组线程，比如一组线程需要在一个时间点上达成一致，例如同时开始一个工作。另外，CyclicBarrier 的循环特性和构造函数所接受的 Runnable 参数也是 CountDownLatch 所不具备的。 SemaphoreSemaphore 直译是信号量，可能称它是许可量更容易理解。当然，因为在计算机科学中这个名字由来已久，所以不能乱改。它的功能比较好理解，就是通过构造函数设定一个数量的许可，然后通过 acquire 方法获得许可，release 方法释放许可。它还有 tryAcquire 和 acquireUninterruptibly 方法，可以根据自己的需要选择 示例：Semaphore 控制资源访问123456789101112131415161718192021222324252627282930313233343536class Pool &#123; private static final int MAX_AVAILABLE = 100; private final Semaphore available = new Semaphore(MAX_AVAILABLE, true); public Object getItem() throws InterruptedException &#123; available.acquire(); return getNextAvailableItem(); &#125; public void putItem(Object x) &#123; if (markAsUnused(x)) available.release(); &#125; // Not a particularly efficient data structure; just for demo protected Object[] items = ... whatever kinds of items being managed protected boolean[] used = new boolean[MAX_AVAILABLE]; protected synchronized Object getNextAvailableItem() &#123; for (int i = 0; i &lt; MAX_AVAILABLE; ++i) &#123; if (!used[i]) &#123; used[i] = true; return items[i]; &#125; &#125; return null; // not reached &#125; protected synchronized boolean markAsUnused(Object item) &#123; for (int i = 0; i &lt; MAX_AVAILABLE; ++i) &#123; if (item == items[i]) &#123; if (used[i]) &#123; used[i] = false; return true; &#125; else return false; &#125; &#125; return false; &#125; &#125; 上面这个示例中 Semaphore 的用法没什么可多讲的。需要留意的是这里面有两个同步方法，不过对吞吐应该没什么影响，因为主要是对一个 boolean 数组做一下 O(n) 的操作，而且每个循环里面的操作很简单，所以速度很快。不过不知道 JUC 里面线程池的控制是怎么做的，本人不才，还没看过那块源代码，得空看看，有知道的也可以说说。 最后一句话总结CountDownLatch 是能使一组线程等另一组线程都跑完了再继续跑；CyclicBarrier 能够使一组线程在一个时间点上达到同步，可以是一起开始执行全部任务或者一部分任务。同时，它是可以循环使用的；Semaphore 是只允许一定数量的线程同时执行一段任务。 原文链接：http://my.oschina.net/lifany/blog/207995]]></content>
      <categories>
        <category>Core Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类的复用]]></title>
    <url>%2F2017%2F09%2F27%2F%E7%B1%BB%E7%9A%84%E5%A4%8D%E7%94%A8%2F</url>
    <content type="text"><![CDATA[代码的复用是编程过程中要实现的重要功能，它可以让我们不必重头开始编写代码。在Java中可以通过组合和继承来实现类的复用 组合要使用组合值需要将对象引用置于新类中即可。这里涉及到组合对象的初始化问题，我们可以在声明对象的同时进行初始化，也可以在构造函数进行初始化、还可以在实例块中进行初始化，或者在对象正要使用之前初始化（惰性初始化）。12345678910111213141516171819202122232425262728293031323334353637383940414243package reusing;import static net.mindview.util.Print.*;class Soap &#123; private String s; public Soap() &#123; print("Soap()"); s = "Constructed"; &#125; public String toString() &#123; return s; &#125;&#125;public class Bath &#123; private String s1 = "Happy", // 1.在定义处初始化 s2 = "Happy", // 1.在定义处初始化 s3, s4; private Soap castille; private int i; private float toy; // 2.构造函数中初始化 public Bath() &#123; print("Inside Bath()"); s3 = "Toy"; toy = 3.14f; castille = new Soap(); &#125; // 3.实例块中初始化 &#123; i = 12; &#125; public String toString() &#123; // 4.惰性初始化 if (s4 == null) &#123; s4 = "Job"; &#125; return "Bath [s1=" + s1 + ", s2=" + s2 + ", s3=" + s3 + ", s4=" + s4 + ", castille=" + castille + ", i=" + i + ", toy=" + toy + "]"; &#125; public static void main(String[] args) &#123; Bath bath = new Bath(); print(bath); &#125;&#125; 继承Java中的继承是通过关键字extends实现的。必须要知道一点Java在创建一个类时总是在继承，要么显示继承你给的基类，要么自动继承Object类。Java会自动在导出类的构造器中插入对基类构造器的调用，以保证对基类的正确初始化。如果基类没有默认的构造函数或者需要需要调用带参数的构造函数进行初始化，就必须用关键字super显示地编写调用基类构造函数的语句。继承为新类提供方法外，还定义了新类和基类之前的关系（新类是现有类的一种类型）。 代理实际上通过代理也可以实现类的复用，代理是基本的设计模式之一，它是为了提供额外的操作，而插入的用来代替“实际”对象的对象。12345678910111213141516171819202122232425262728293031323334353637383940414243444546package reusing;import static net.mindview.util.Print.*;class SpaceShipControls &#123; void up(int velocity) &#123;&#125; void down(int velocity) &#123;&#125; void left(int velocity) &#123;&#125; void right(int velocity) &#123;&#125; void forward(int velocity) &#123;&#125; void back(int velocity) &#123;&#125; void truboBoost() &#123;&#125;&#125;public class SpaceShipDelegation &#123; private String name; private SpaceShipControls controls = new SpaceShipControls(); public SpaceShipDelegation(String name) &#123; this.name = name; &#125; public void up(int velocity) &#123; print(name); controls.up(velocity); &#125; public void down(int velocity) &#123; print(name); controls.down(velocity); &#125; public void left(int velocity) &#123; print(name); controls.left(velocity); &#125; public void right(int velocity) &#123; print(name); controls.right(velocity); &#125; public void forward(int velocity) &#123; print(name); controls.forward(velocity); &#125; public void back(int velocity) &#123; print(name); controls.back(velocity); &#125; public static void main(String[] args) &#123; SpaceShipDelegation delegation = new SpaceShipDelegation("NSEA Protector"); delegation.forward(100); &#125;&#125; 知识点如何确保正确的清理Java中并没有C++析构函数的概念，垃圾回收机制会在必要的时候帮助我们释放其内存。通常情况下这样做是没有问题的，但是垃圾回收机制并不能保证何时会调用或者是否将被调用，而有时类可能需要在其生命周期内执行一些必要的清理活动。这样你就必须显式编写一个清理方法来做这件事情。finally子句是执行清理动作的好地方，不建议使用finalize()方法。 组合和继承的选择记住一个规则：is-a(是一个)的关系用继承来表达，has-a(有一个)的关系用组合来表达。以交通工具为例：车子是一种交通工具（is-a），车子包含引擎，轮胎等（has-a）。虽然继承在OOP编程中占有举足轻重的作用，但是实际上我们应该慎用继承。对于到底该用继承还是组合，简单的办法就是判断是否需要从新类向基类向上转型。 protected关键字protected关键字指明“对于任何继承此类的的导出类或其它任何位于同一个包中内的类来说，它是可以访问的”。尽力对域设置private，然后通过protected方法来控制继承者的访问权限。 向上转型我们可以将一个导出类赋给一个基类的引用，这种将导出类引用转换成基类应用的动作，称之为“向上转型”。 final关键字final关键字可用于数据、方法和类。当final用于数据时，如果数据是基本数据类型，那么该数据不能改变，如果数据不是基本数据类型，那么指向数据的引用不能改变，但是数据本身可以改变。final数据可以在定义时初始化，也可以通过构造函数初始化。当final作用于方法的参数列表时，表示该参数所指向的对象无法在方法内更改。在方法上使用final关键字的主要原因是把方法锁定，以防止任何继承类修改它的含义（想要确保在继承中方法的行为保持不变，并且不会被覆盖）。当将某个类的整体定义为final时，就表明你不打算继承该类，也不允许别人怎么做。]]></content>
      <categories>
        <category>Core Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面相对对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从MVC到前后端分离]]></title>
    <url>%2F2016%2F10%2F26%2F%E4%BB%8EMVC%E5%88%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[摘要：MVC模式早在上个世纪70年代就诞生了，直到今天它依然存在，可见生命力相当之强。MVC模式最早用于Smalltalk语言中，最后在其它许多开发语言中都得到了很好的应用，例如，Java中的Struts、Spring MVC等框架。 理解MVCMVC是一种经典的设计模式，全名为Model-View-Controller，即模型-视图-控制器。 其中，模型是用于封装数据的载体，例如，在Java中一般通过一个简单的POJO（Plain Ordinary Java Object）来表示，其本质是一个普通的Java Bean，包含一系列的成员变量及其getter/setter方法。对于视图而言，它更加偏重于展现，也就是说，视图决定了界面到底长什么样子，在Java中可通过JSP来充当视图，或者通过纯HTML的方式进行展现，而后者才是目前的主流。模型和视图需要通过控制器来进行粘合，例如，用户发送一个HTTP请求，此时该请求首先会进入控制器，然后控制器去获取数据并将其封装为模型，最后将模型传递到视图中进行展现。 综上所述，MVC的交互过程如图1所示：[] MVC模式的优点与不足MVC模式早在上个世纪70年代就诞生了，直到今天它依然存在，可见生命力相当之强。MVC模式最早用于Smalltalk语言中，最后在其它许多开发语言中都得到了很好的应用，例如，Java中的Struts、Spring MVC等框架。正是因为这些MVC框架的出现，才让MVC模式真正落地，让开发更加高效，让代码耦合度尽量减小，让应用程序各部分的职责更加清晰。 既然MVC模式这么好，难道它就没有不足的地方吗？我认为MVC至少有以下三点不足： 每次请求必须经过“控制器-&gt;模型-&gt;视图”这个流程，用户才能看到最终的展现的界面，这个过程似乎有些复杂。 实际上视图是依赖于模型的，换句话说，如果没有模型，视图也无法呈现出最终的效果。 渲染视图的过程是在服务端来完成的，最终呈现给浏览器的是带有模型的视图页面，性能无法得到很好的优化。 为了使数据展现过程更加直接，并且提供更好的用户体验，我们有必要对MVC模式进行改进。不妨这样来尝试，首先从浏览器发送AJAX请求，然后服务端接受该请求并返回JSON数据返回给浏览器，最后在浏览器中进行界面渲染。 改进后的MVC模式如图2所示：[] 也就是说，我们输入的是AJAX请求，输出的是JSON数据，市面上有这样的技术来实现这个功能吗？答案是REST。 REST全称是Representational State Transfer（表述性状态转移），它是Roy Fielding博士在2000年写的一篇关于软件架构风格的论文，此文一出，威震四方！国内外许多知名互联网公司纷纷开始采用这种轻量级的Web服务，大家习惯将其称为RESTful Web Services，或简称REST服务。] 如果将浏览器这一端视为前端，而服务器那一端视为后端的话，可以将以上改进后的MVC模式简化为以下前后端分离模式，如图3所示。[] 认识RESTREST本质上是使用URL来访问资源种方式。众所周知，URL就是我们平常使用的请求地址了，其中包括两部分：请求方式与请求路径，比较常见的请求方式是GET与POST，但在REST中又提出了几种其它类型的请求方式，汇总起来有六种：GET、POST、PUT、DELETE、HEAD、OPTIONS。尤其是前四种，正好与CRUD（Create-Retrieve-Update-Delete，增删改查）四种操作相对应，例如，GET（查）、POST（增）、PUT（改）、DELETE（删），这正是REST与CRUD的异曲同工之妙！需要强调的是，REST是“面向资源”的，这里提到的资源，实际上就是我们常说的领域对象，在系统设计过程中，我们经常通过领域对象来进行数据建模。 REST是一个“无状态”的架构模式，因为在任何时候都可以由客户端发出请求到服务端，最终返回自己想要的数据，当前请求不会受到上次请求的影响。也就是说，服务端将内部资源发布REST服务，客户端通过URL来访问这些资源，这不就是SOA所提倡的“面向服务”的思想吗？所以，REST也被人们看做是一种“轻量级”的SOA实现技术，因此在企业级应用与互联网应用中都得到了广泛应用。 下面我们举几个例子对REST请求进行简单描述：[]可见，请求路径相同，但请求方式不同，所代表的业务操作也不同，例如，/advertiser/1这个请求，带有GET、PUT、DELETE三种不同的请求方式，对应三种不同的业务操作。 虽然REST看起来还是很简单的，实际上我们往往需要提供一个REST框架，让其实现前后端分离架构，让开发人员将精力集中在业务上，而并非那些具体的技术细节。下面我们将使用Java技术来实现这个REST框架，整体框架会基于Spring进行开发。 实现REST框架统一响应结构使用REST框架实现前后端分离架构，我们需要首先确定返回的JSON响应结构是统一的，也就是说，每个REST请求将返回相同结构的JSON响应结构。不妨定义一个相对通用的JSON响应结构，其中包含两部分：元数据与返回值，其中，元数据表示操作是否成功与返回值消息等，返回值对应服务端方法所返回的数据。该JSON响应结构如下：1234567&#123; "meta": &#123; "success": true, "message": "ok" &#125;, "data": ...&#125; 为了在框架中映射以上JSON响应结构，我们需要编写一个Response类与其对应：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Response &#123; private static final String OK = "ok"; private static final String ERROR = "error"; private Meta meta; private Object data; public Response success() &#123; this.meta = new Meta(true, OK); return this; &#125; public Response success(Object data) &#123; this.meta = new Meta(true, OK); this.data = data; return this; &#125; public Response failure() &#123; this.meta = new Meta(false, ERROR); return this; &#125; public Response failure(String message) &#123; this.meta = new Meta(false, message); return this; &#125; public Meta getMeta() &#123; return meta; &#125; public Object getData() &#123; return data; &#125; public class Meta &#123; private boolean success; private String message; public Meta(boolean success) &#123; this.success = success; &#125; public Meta(boolean success, String message) &#123; this.success = success; this.message = message; &#125; public boolean isSuccess() &#123; return success; &#125; public String getMessage() &#123; return message; &#125; &#125; &#125; 以上Response类包括两类通用返回值消息：ok与error，还包括两个常用的操作方法：success( )与failure( )，通过一个内部类来展现元数据结构，我们在下文中多次会使用该Response类。 实现该REST框架需要考虑许多问题，首当其冲的就是对象序列化问题。 实现对象序列化想要解释什么是对象序列化？不妨通过一些例子进行说明。比如，通过浏览器发送了一个普通的HTTP请求，该请求携带了一个JSON格式的参数，在服务端需要将该JSON参数转换为普通的Java对象，这个转换过程称为序列化。再比如，在服务端获取了数据，此时该数据是一个普通的Java对象，然后需要将这个Java对象转换为JSON字符串，并将其返回到浏览器中进行渲染，这个转换过程称为反序列化。不管是序列化还是反序列化，我们一般都称为序列化。 实际上，Spring MVC已经为我们提供了这类序列化特性，只需在Controller的方法参数中使用@RequestBody注解定义需要反序列化的参数即可，如以下代码片段：1234567@Controllerpublic class AdvertiserController &#123; @RequestMapping(value = "/advertiser", method = RequestMethod.POST) public Response createAdvertiser(@RequestBody AdvertiserParam advertiserParam) &#123; ... &#125;&#125; 若需要对Controller的方法返回值进行序列化，则需要在该返回值上使用@ResponseBody注解来定义，如以下代码片段：1234567@Controller public class AdvertiserController &#123; @RequestMapping(value = "/advertiser/&#123;id&#125;", method = RequestMethod.GET) public @ResponseBody Response getAdvertiser(@PathVariable("id") String advertiserId) &#123; ... &#125; &#125; 当然，@ResponseBody注解也可以定义在类上，这样所有的方法都继承了该特性。由于经常会使用到@ResponseBody注解，所以Spring提供了一个名为@RestController的注解来取代以上的@Controller注解，这样我们就可以省略返回值前面的@ResponseBody注解了，但参数前面的@RequestBody注解是无法省略的。实际上，看看Spring中对应@RestController注解的源码便可知晓：12345678@Target(&#123;ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @Controller @ResponseBody public @interface RestController &#123; String value() default ""; &#125; 可见，@RestController注解已经被@Controller与@ResponseBody注解定义过了，Spring框架会识别这类注解。需要注意的是，该特性在Spring 4.0中才引入。 因此，我们可将以上代码进行如下改写：123456789101112@RestController public class AdvertiserController &#123; @RequestMapping(value = "/advertiser", method = RequestMethod.POST) public Response createAdvertiser(@RequestBody AdvertiserParam advertiserParam) &#123; ... &#125; @RequestMapping(value = "/advertiser/&#123;id&#125;", method = RequestMethod.GET) public Response getAdvertiser(@PathVariable("id") String advertiserId) &#123; ... &#125; &#125; 除了使用注解来定义序列化行为以外，我们还需要使用Jackson来提供JSON的序列化操作，在Spring配置文件中只需添加以下配置即可：12345&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"/&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 若需要对Jackson的序列化行为进行定制，比如，排除值为空属性、进行缩进输出、将驼峰转为下划线、进行日期格式化等，这又如何实现呢？ 首先，我们需要扩展Jackson提供的ObjectMapper类，代码如下：1234567891011121314151617181920212223242526272829public class CustomObjectMapper extends ObjectMapper &#123; private boolean camelCaseToLowerCaseWithUnderscores = false; private String dateFormatPattern; public void setCamelCaseToLowerCaseWithUnderscores(boolean camelCaseToLowerCaseWithUnderscores) &#123; this.camelCaseToLowerCaseWithUnderscores = camelCaseToLowerCaseWithUnderscores; &#125; public void setDateFormatPattern(String dateFormatPattern) &#123; this.dateFormatPattern = dateFormatPattern; &#125; public void init() &#123; // 排除值为空属性 setSerializationInclusion(JsonInclude.Include.NON_NULL); // 进行缩进输出 configure(SerializationFeature.INDENT_OUTPUT, true); // 将驼峰转为下划线 if (camelCaseToLowerCaseWithUnderscores) &#123; setPropertyNamingStrategy(PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES); &#125; // 进行日期格式化 if (StringUtil.isNotEmpty(dateFormatPattern)) &#123; DateFormat dateFormat = new SimpleDateFormat(dateFormatPattern); setDateFormat(dateFormat); &#125; &#125; &#125; 然后，将CustomObjectMapper注入到MappingJackson2HttpMessageConverter中，Spring配置如下：123456789101112&lt;bean id="objectMapper" class="com.xxx.api.json.CustomObjectMapper" init-method="init"&gt; &lt;property name="camelCaseToLowerCaseWithUnderscores" value="true"/&gt; &lt;property name="dateFormatPattern" value="yyyy-MM-dd HH:mm:ss"/&gt; &lt;/bean&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"&gt; &lt;property name="objectMapper" ref="objectMapper"/&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 通过以上过程，我们已经完成了一个基于Spring MVC的REST框架，只不过该框架还非常单薄，还缺乏很多关键性特性，尤其是异常处理。 处理异常行为在Spring MVC中，我们可以使用AOP技术，编写一个全局的异常处理切面类，用它来统一处理所有的异常行为，在Spring 3.2中才开始提供。使用法很简单，只需定义一个类，并通过@ControllerAdvice注解将其标注即可，同时需要使用@ResponseBody注解表示返回值可序列化为JSON字符串。代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344@ControllerAdvice @ResponseBody public class ExceptionAdvice &#123; /** * 400 - Bad Request */ @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(HttpMessageNotReadableException.class) public Response handleHttpMessageNotReadableException(HttpMessageNotReadableException e) &#123; logger.error("参数解析失败", e); return new Response().failure("could_not_read_json"); &#125; /** * 405 - Method Not Allowed */ @ResponseStatus(HttpStatus.METHOD_NOT_ALLOWED) @ExceptionHandler(HttpRequestMethodNotSupportedException.class) public Response handleHttpRequestMethodNotSupportedException(HttpRequestMethodNotSupportedException e) &#123; logger.error("不支持当前请求方法", e); return new Response().failure("request_method_not_supported"); &#125; /** * 415 - Unsupported Media Type */ @ResponseStatus(HttpStatus.UNSUPPORTED_MEDIA_TYPE) @ExceptionHandler(HttpMediaTypeNotSupportedException.class) public Response handleHttpMediaTypeNotSupportedException(Exception e) &#123; logger.error("不支持当前媒体类型", e); return new Response().failure("content_type_not_supported"); &#125; /** * 500 - Internal Server Error */ @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(Exception.class) public Response handleException(Exception e) &#123; logger.error("服务运行异常", e); return new Response().failure(e.getMessage()); &#125; &#125; 可见，在ExceptionAdvice类中包含一系列的异常处理方法，每个方法都通过@ResponseStatus注解定义了响应状态码，此外还通过@ExceptionHandler注解指定了具体需要拦截的异常类。以上过程只是包含了一部分的异常情况，若需处理其它异常，可添加方法具体的方法。需要注意的是，在运行时从上往下依次调用每个异常处理方法，匹配当前异常类型是否与@ExceptionHandler注解所定义的异常相匹配，若匹配，则执行该方法，同时忽略后续所有的异常处理方法，最终会返回经JSON序列化后的Response对象。 支持参数验证我们回到上文所提到的示例，这里处理一个普通的POST请求，代码如下：1234567@RestController public class AdvertiserController &#123; @RequestMapping(value = "/advertiser", method = RequestMethod.POST) public Response createAdvertiser(@RequestBody AdvertiserParam advertiserParam) &#123; ... &#125; &#125; 其中，AdvertiserParam参数包含若干属性，通过以下类结构可见，它是一个传统的POJO：1234567public class AdvertiserParam &#123; private String advertiserName; private String description; // 省略 getter/setter 方法 &#125; 如果业务上需要确保AdvertiserParam对象的advertiserName属性必填，如何实现呢？ 若将这类参数验证的代码写死在Controller中，势必会与正常的业务逻辑搅在一起，导致责任不够单一，违背于“单一责任原则”。建议将其参数验证行为从Controller中剥离出来，放到另外的类中，这里仅提供一个@Valid注解来定义AdvertiserParam参数，并在AdvertiserParam类中通过@NotEmpty注解来定义advertiserName属性，就像下面这样：1234567891011121314151617@RestController public class AdvertiserController &#123; @RequestMapping(value = "/advertiser", method = RequestMethod.POST) public Response createAdvertiser(@RequestBody @Valid AdvertiserParam advertiserParam) &#123; ... &#125; &#125; public class AdvertiserParam &#123; @NotEmpty private String advertiserName; private String description; // 省略 getter/setter 方法 &#125; 这里的@Valid注解实际上是Validation Bean规范提供的注解，该规范已由Hibernate Validator框架实现，因此需要添加以下Maven依赖到pom.xml文件中：12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate-validator.version&#125;&lt;/version&gt; &lt;/dependency&gt; 需要注意的是，Hibernate Validator与Hibernate没有任何依赖关系，唯一有联系的只是都属于JBoss公司的开源项目而已。 要实现@NotEmpty注解的功能，我们需要做以下几件事情。 首先，定义一个@NotEmpty注解类，代码如下：123456789101112@Documented @Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;) @Retention(RetentionPolicy.RUNTIME) @Constraint(validatedBy = NotEmptyValidator.class) public @interface NotEmpty &#123; String message() default "not_empty"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; &#125; 以上注解类必须包含message、groups、payload三个属性，因为这是规范所要求的，此外，需要通过@Constraint注解指定一个验证器类，这里对应的是NotEmptyValidator，其代码如下：1234567891011public class NotEmptyValidator implements ConstraintValidator&lt;NotEmpty, String&gt; &#123; @Override public void initialize(NotEmpty constraintAnnotation) &#123; &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; return StringUtil.isNotEmpty(value); &#125; &#125; 以上验证器类实现了ConstraintValidator接口，并在该接口的isValid( )方法中完成了具体的参数验证逻辑。需要注意的是，实现接口时需要指定泛型，第一个参数表示验证注解类型（NotEmpty），第二个参数表示需要验证的参数类型（String）。 然后，我们需要在Spring配置文件中开启该特性，需添加如下配置：1&lt;bean class="org.springframework.validation.beanvalidation.MethodValidationPostProcessor"/&gt; 最后，需要在全局异常处理类中添加参数验证处理方法，代码如下：1234567891011121314@ControllerAdvice @ResponseBody public class ExceptionAdvice &#123; /** * 400 - Bad Request */ @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(ValidationException.class) public Response handleValidationException(ValidationException e) &#123; logger.error("参数验证失败", e); return new Response().failure("validation_exception"); &#125; &#125; 至此，REST框架已集成了Bean Validation特性，我们可以使用各种注解来完成所需的参数验证行为了。 看似该框架可以在本地成功跑起来，整个架构包含两个应用，前端应用提供纯静态的HTML页面，后端应用发布REST API，前端需要通过AJAX调用后端发布的REST API，然而AJAX是不支持跨域访问的，也就是说，前后端两个应用必须在同一个域名下才能访问。这是非常严重的技术障碍，一定需要找到解决方案。 解决跨域问题比如，前端应用为静态站点且部署在http://web.xxx.com域下，后端应用发布REST API并部署在http://api.xxx.com域下，如何使前端应用通过AJAX跨域访问后端应用呢？这需要使用到CORS技术来实现，这也是目前最好的解决方案了。 CORS全称为Cross Origin Resource Sharing（跨域资源共享），服务端只需添加相关响应头信息，即可实现客户端发出AJAX跨域请求。 CORS技术非常简单，易于实现，目前绝大多数浏览器均已支持该技术（IE8浏览器也支持了），服务端可通过任何编程语言来实现，只要能将CORS响应头写入response对象中即可。 下面我们继续扩展REST框架，通过CORS技术实现AJAX跨域访问。 首先，我们需要编写一个Filter，用于过滤所有的HTTP请求，并将CORS响应头写入response对象中，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class CorsFilter implements Filter &#123; private String allowOrigin; private String allowMethods; private String allowCredentials; private String allowHeaders; private String exposeHeaders; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; allowOrigin = filterConfig.getInitParameter("allowOrigin"); allowMethods = filterConfig.getInitParameter("allowMethods"); allowCredentials = filterConfig.getInitParameter("allowCredentials"); allowHeaders = filterConfig.getInitParameter("allowHeaders"); exposeHeaders = filterConfig.getInitParameter("exposeHeaders"); &#125; @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; if (StringUtil.isNotEmpty(allowOrigin)) &#123; List&lt;String&gt; allowOriginList = Arrays.asList(allowOrigin.split(",")); if (CollectionUtil.isNotEmpty(allowOriginList)) &#123; String currentOrigin = request.getHeader("Origin"); if (allowOriginList.contains(currentOrigin)) &#123; response.setHeader("Access-Control-Allow-Origin", currentOrigin); &#125; &#125; &#125; if (StringUtil.isNotEmpty(allowMethods)) &#123; response.setHeader("Access-Control-Allow-Methods", allowMethods); &#125; if (StringUtil.isNotEmpty(allowCredentials)) &#123; response.setHeader("Access-Control-Allow-Credentials", allowCredentials); &#125; if (StringUtil.isNotEmpty(allowHeaders)) &#123; response.setHeader("Access-Control-Allow-Headers", allowHeaders); &#125; if (StringUtil.isNotEmpty(exposeHeaders)) &#123; response.setHeader("Access-Control-Expose-Headers", exposeHeaders); &#125; chain.doFilter(req, res); &#125; @Override public void destroy() &#123; &#125; &#125; 以上CorsFilter将从web.xml中读取相关Filter初始化参数，并将在处理HTTP请求时将这些参数写入对应的CORS响应头中，下面大致描述一下这些CORS响应头的意义： Access-Control-Allow-Origin：允许访问的客户端域名，例如：http://web.xxx.com，若为*，则表示从任意域都能访问，即不做任何限制。 Access-Control-Allow-Methods：允许访问的方法名，多个方法名用逗号分割，例如：GET,POST,PUT,DELETE,OPTIONS。 Access-Control-Allow-Credentials：是否允许请求带有验证信息，若要获取客户端域下的cookie时，需要将其设置为true。 Access-Control-Allow-Headers：允许服务端访问的客户端请求头，多个请求头用逗号分割，例如：Content-Type。 Access-Control-Expose-Headers：允许客户端访问的服务端响应头，多个响应头用逗号分割。 需要注意的是，CORS规范中定义Access-Control-Allow-Origin只允许两种取值，要么为*，要么为具体的域名，也就是说，不支持同时配置多个域名。为了解决跨多个域的问题，需要在代码中做一些处理，这里将Filter初始化参数作为一个域名的集合（用逗号分隔），只需从当前请求中获取Origin请求头，就知道是从哪个域中发出的请求，若该请求在以上允许的域名集合中，则将其放入Access-Control-Allow-Origin响应头，这样跨多个域的问题就轻松解决了。 以下是web.xml中配置CorsFilter的方法：123456789101112131415161718192021222324&lt;filter&gt; &lt;filter-name&gt;corsFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.xxx.api.cors.CorsFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;allowOrigin&lt;/param-name&gt; &lt;param-value&gt;http://web.xxx.com&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;allowMethods&lt;/param-name&gt; &lt;param-value&gt;GET,POST,PUT,DELETE,OPTIONS&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;allowCredentials&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;allowHeaders&lt;/param-name&gt; &lt;param-value&gt;Content-Type&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;corsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 完成以上过程即可实现AJAX跨域功能了，但似乎还存在另外一个问题，由于REST是无状态的，后端应用发布的REST API可在用户未登录的情况下被任意调用，这显然是不安全的，如何解决这个问题呢？我们需要为REST请求提供安全机制。 提供安全机制解决REST安全调用问题，可以做得很复杂，也可以做得特简单，可按照以下过程提供REST安全机制： 当用户登录成功后，在服务端生成一个token，并将其放入内存中（可放入JVM或Redis中），同时将该token返回到客户端。 在客户端中将返回的token写入cookie中，并且每次请求时都将token随请求头一起发送到服务端。 提供一个AOP切面，用于拦截所有的Controller方法，在切面中判断token的有效性。 当登出时，只需清理掉cookie中的token即可，服务端token可设置过期时间，使其自行移除。 首先，我们需要定义一个用于管理token的接口，包括创建token与检查token有效性的功能。代码如下：123456public interface TokenManager &#123; String createToken(String username); boolean checkToken(String token); &#125; 然后，我们可提供一个简单的TokenManager实现类，将token存储到JVM内存中。代码如下：12345678910111213141516public class DefaultTokenManager implements TokenManager &#123; private static Map&lt;String, String&gt; tokenMap = new ConcurrentHashMap&lt;&gt;(); @Override public String createToken(String username) &#123; String token = CodecUtil.createUUID(); tokenMap.put(token, username); return token; &#125; @Override public boolean checkToken(String token) &#123; return !StringUtil.isEmpty(token) &amp;&amp; tokenMap.containsKey(token); &#125; &#125; 需要注意的是，如果需要做到分布式集群，建议基于Redis提供一个实现类，将token存储到Redis中，并利用Redis与生俱来的特性，做到token的分布式一致性。 然后，我们可以基于Spring AOP写一个切面类，用于拦截Controller类的方法，并从请求头中获取token，最后对token有效性进行判断。代码如下：12345678910111213141516171819202122232425262728293031323334353637public class SecurityAspect &#123; private static final String DEFAULT_TOKEN_NAME = "X-Token"; private TokenManager tokenManager; private String tokenName; public void setTokenManager(TokenManager tokenManager) &#123; this.tokenManager = tokenManager; &#125; public void setTokenName(String tokenName) &#123; if (StringUtil.isEmpty(tokenName)) &#123; tokenName = DEFAULT_TOKEN_NAME; &#125; this.tokenName = tokenName; &#125; public Object execute(ProceedingJoinPoint pjp) throws Throwable &#123; // 从切点上获取目标方法 MethodSignature methodSignature = (MethodSignature) pjp.getSignature(); Method method = methodSignature.getMethod(); // 若目标方法忽略了安全性检查，则直接调用目标方法 if (method.isAnnotationPresent(IgnoreSecurity.class)) &#123; return pjp.proceed(); &#125; // 从 request header 中获取当前 token String token = WebContext.getRequest().getHeader(tokenName); // 检查 token 有效性 if (!tokenManager.checkToken(token)) &#123; String message = String.format("token [%s] is invalid", token); throw new TokenException(message); &#125; // 调用目标方法 return pjp.proceed(); &#125; &#125; 若要使SecurityAspect生效，则需要添加如下Spring 配置：12345678910&lt;bean id="securityAspect" class="com.xxx.api.security.SecurityAspect"&gt; &lt;property name="tokenManager" ref="tokenManager"/&gt; &lt;property name="tokenName" value="X-Token"/&gt; &lt;/bean&gt; &lt;aop:config&gt; &lt;aop:aspect ref="securityAspect"&gt; &lt;aop:around method="execute" pointcut="@annotation(org.springframework.web.bind.annotation.RequestMapping)"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 最后，别忘了在web.xml中添加允许的X-Token响应头，配置如下：1234&lt;init-param&gt; &lt;param-name&gt;allowHeaders&lt;/param-name&gt; &lt;param-value&gt;Content-Type,X-Token&lt;/param-value&gt; &lt;/init-param&gt; 总结本文从经典的MVC模式开始，对MVC模式是什么以及该模式存在的不足进行了简述。然后引出了如何对MVC模式的改良，让其转变为前后端分离架构，以及解释了为何要进行前后端分离。最后通过REST服务将前后端进行解耦，并提供了一款基于Java的REST框架的主要实现过程，尤其是需要注意的核心技术问题及其解决方案。希望本文对正在探索前后端分离的读者们有所帮助，期待与大家共同探讨。 原文链接： http://www.csdn.net/article/2015-10-25/2826033]]></content>
      <categories>
        <category>架构之路</category>
      </categories>
      <tags>
        <tag>Restfull</tag>
        <tag>MVC</tag>
        <tag>软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Java中创建一个类？]]></title>
    <url>%2F2016%2F02%2F27%2F2%20How%20to%20create%20a%20class%20in%20Java%2F</url>
    <content type="text"><![CDATA[类是面向对象范式编程中的基本单元。本文向你展示了在编写Java类时，将需要了解的一些基本但重要的内容。类是创建对象的模板，Java中的类可能包含下面五个组件： 字段 方法 构造函数 静态块 实例块 字段和方法也称为类的成员，剩下的3个组件用于初始化类，即使用类模板创建对象。构造函数用于创建类的对象，类必须至少有一个构造函数（如果没有明确声明，JVM会注册一个默认的构造函数）。静态块和实例块用于初始化类的字段。类可以拥有零个或多个静态块或实例块。 如何声明一个类在Java中声明一个类的语法如下：123&lt;&lt;modifiers&gt;&gt; class &lt;&lt;class name&gt;&gt; &#123; // Body of the class goes here&#125; 类声明可能有零个或多个修饰符。关键字class用于声明一个类。&lt;&lt; class name &gt;&gt;是用户定义的类名，它应该是一个有效的标识符。每个类都有一个主体，它在一对大括号({})中指定。类的主体包含其不同的组件，例如字段，方法等。下面是类声明的一个例子：1234// Main.java filenameclass Main &#123; // Empty body for now; Write you own&#125; 如何声明一个类中的字段类的字段表示该类的对象的属性（也称为属性）。这些字段在类的体内声明。在类中声明一个字段的一般语法是：1234&lt;&lt;modifiers&gt;&gt; class &lt;&lt;class name&gt;&gt; &#123; // A field declaration &lt;&lt;modifiers&gt;&gt; &lt;&lt;data type&gt;&gt; &lt;&lt;field name&gt;&gt; = &lt;&lt;initial value&gt;&gt;;&#125; 以人为例，假设每个人都有两个属性：一个名字和一个性别。类应包括两个字段的声明：一个表示名称，一个表示性别。所以声明的字段将如下所示：12345// Human.javaclass Human &#123; String name; String gender;&#125; 创建类的实例以下是创建类的实例的一般语法：123&lt;&lt;Class&gt;&gt; &lt;&lt;variable&gt;&gt; = new &lt;&lt;Call to Class Constructor&gt;&gt;;//e.g.Human h = new Human(); 当您没有显示添加构造函数时，Java编译器为您添加一个。由Java编译器添加的构造函数称为默认构造函数。默认构造函数不接受参数。类的构造函数的名称与类名称相同。new运算符后跟一个调用实例正在创建的类的构造函数。new运算符通过在堆上分配内存来创建类的实例。 Java中的null引用类型Java有一个特殊的引用类型，称为null类型。 它没有名字，您无法定义null引用类型的变量。 null引用类型只有一个由Java定义的值，它是空文本， 它只是空。 空引用类型是与任何其他引用类型兼容的赋值。 也就是说，您可以为任何引用类型的变量分配一个空值。 实际上，存储在引用类型变量中的空值意味着引用变量是指没有对象。123// Assign null value to johnHuman john = null; // john is not referring to any objectjohn = new Human(); // Now, john is referring to a valid Human object 请注意，null是null类型的文字。您不能将null分配给原始类型变量，这就是为什么java编译器不允许将原始值与空值进行比较的原因。 构造函数（Constructors）构造函数是一个命名的代码块，用于在对象创建后立即初始化类的对象。构造函数声明的一般语法是：123&lt;&lt;Modifiers&gt;&gt; &lt;&lt;Constructor Name&gt;&gt;(&lt;&lt;parameters list&gt;&gt;) throws &lt;&lt;Exceptions list&gt;&gt; &#123; // Body of constructor goes here&#125; 构造函数可以将其访问修饰符设置为public，private，protected或package-level（无修饰符）。构造函数名称与类的名称相同。构造函数名称后面是一对括号，可以包括参数。可选地，右括号后面可以是关键字throws，后面是逗号分隔的异常列表。与方法不同，构造函数不具有返回类型。你甚至不能将void指定为构造函数的返回类型。如果有任何返回类型，那么它是方法。请记住，如果构造的名称与类的简单名称相同，则可以是方法或构造函数。如果它指定一个返回类型，它是一种方法。如果没有指定返回类型，它是一个构造函数。 实例块你看到一个构造函数用于初始化一个类的实例。实例块（也称为实例初始化程序）也用于初始化类的对象。一个实例块只是一个类的一个代码块，但在任何方法或构造函数之外。实例初始化程序没有名称。它的代码简单地放在一个一对大括号内。请注意，实例初始化程序在实例上下文中执行，关键字在实例初始化程序中可用。1234// An instance initializer&#123; /* Other code for the instance initializer goes here */&#125; 一个实例块不能有一个返回语句。它不能抛出检查异常，除非所有声明的构造函数在其throws子句中列出这些检查的异常。 静态块静态块也称为静态初始化程序。它类似于实例块。它用于初始化一个类。每个对象执行一次实例初始化程序，而当类定义加载到JVM中时，静态初始化程序只对类执行一次。为了将其与实例初始化程序区分开，您需要在其声明开头使用static关键字。你可以在一个类中有多个静态块。所有的静态初块都按照出现的文本顺序执行，并在任何实例初始化器之前执行。1234// An static initializerstatic &#123; /* Other code for the static initializer goes here */&#125; 一个静态块能抛出被检查的异常，它不能有一个返回语句。]]></content>
      <categories>
        <category>Core Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Core Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是Java编程语言？]]></title>
    <url>%2F2016%2F02%2F26%2F1%20What%20is%20Java%20programming%20language%2F</url>
    <content type="text"><![CDATA[Java是一种通用的计算机编程语言，它是并发的，基于类的，面向对象的，并且被专门设计为具有尽可能少的实现依赖性。它旨在让应用程序开发人员”write once, run anywhere“（WORA），这意味着编译的Java代码可以在支持Java的所有平台上运行，而无需重新编译。例如，您可以在UNIX上编写和编译Java程序，并在Microsoft Windows，Macintosh或UNIX机器上运行它，而不对源代码进行任何修改。WORA是通过将Java程序编译成一个称为字节码的中间语言来实现。字节码与平台无关，可以在运行Java虚拟机（JVM）的每个平台上运行字节码。 Java最初由Sun Microsystems（后被Oracle Corporation收购）的James Gosling开发，并于1995年发布，作为Sun Microsystems Java平台的核心组件。该语言源自C和C ++的大部分语法，但是它的底层操作比其中任何一个都要少。 甲骨文公司是2010年1月27日收购Sun Microsystems之后正式实施Java SE平台的所有者。这个实现是基于Sun的原始实现。 Oracle实现可用于Microsoft Windows，Mac OS X，Linux和Solaris。 Oracle实现被打包成两个不同的发行版：Java运行时环境（JRE），其中包含运行Java程序所需的Java SE平台的部分内容，并且适用于最终用户以及Java Development Kit（JDK） 适用于软件开发人员，并且包括开发工具，如Java编译器，Javadoc，Jar和调试器。Java使用自动垃圾回收器（garbage collector）来管理对象生命周期中的内存。程序员确定何时创建对象，并且一旦对象不再使用，Java运行时就负责恢复内存。一旦没有任何引用指向对象，并且对象依然存在，那么无法访问对象占用的内存就有资格被垃圾收集器自动释放。如果程序员的代码持有对不再需要的对象的引用，通常当不再需要的对象存储在仍在使用的容器中时，可能仍然会发生类似于内存泄漏的内容。如果调用不存在对象的方法，则抛出“空指针异常”。垃圾收集可能随时发生。理想情况下，程序空闲时会发生。如果堆上没有足够的可用内存来分配一个新的对象，则保证被触发;这可能导致程序暂停。显式内存管理在Java中是不可能的。 以“Hello，world！”为例，程序可以用Java编写为：12345public class HelloWorldApplication &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); // Prints the string to the console. &#125;&#125; 源文件必须以其包含的公共类命名，并以.java未后缀，例如HelloWorldApplication.java。它必须首先使用Java编译器编译成字节码，生成一个名为HelloWorldApplication.class的文件。只有这样才能执行，或者“启动”。 Java源文件只能包含一个公共类，但它可以包含多个类，而不包括公共访问和任何数量的公共内部类。当源文件包含多个类时，使一个类’public’，并使用该公共类名命名源文件。 我们将在后面的教程中看到有关Java语言其他更多的特性。]]></content>
      <categories>
        <category>Core Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Core Java</tag>
      </tags>
  </entry>
</search>
