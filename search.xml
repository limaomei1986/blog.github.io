<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java并发 - CountDownLatch示例]]></title>
    <url>%2F2017%2F09%2F27%2FJava%E5%B9%B6%E5%8F%91-CountDownLatch%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。在Java并发中，countdownlatch的概念是一个常见的面试题，所以一定要确保你很好的理解了它。在这篇文章中，将会涉及到在Java并发编程中跟CountDownLatch相关的以下几点： 目录 CountDownLatch是什么？ CountDownLatch如何工作？ 在实时系统中的应用场景 应用范例 常见的面试题 CountDownLatch是什么CountDownLatch是在Java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，&gt;然后在闭锁上等待的线程就可以恢复执行任务。 CountDownLatch如何工作CountDownLatch.java类中定义的构造函数：12//Constructs a CountDownLatch initialized with the given count.public void CountDownLatch(int count) &#123;...&#125; 构造器中的计数值（count）实际上就是闭锁需要等待的线程数量。这个值只能被设置一次，而且CountDownLatch没有提供任何机制去重新设置这个计数值。与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await()方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成&gt;各自的任务。其他N 个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过CountDownLatch.countDown()方法来完成的；每调用一次这个方&gt;法，在构造函数中初始化的count值就减1。所以当N个线程都调 用了这个方法，count的值等于0，然后主线程就能通过await()方法，恢复执行自己的任务。 在实时系统中的使用场景让我们尝试罗列出在java实时系统中CountDownLatch都有哪些使用场景。我所罗列的都是我所能想到的。如果你有别的可能的使用方法，请在留言里列出来，这样会帮助到大家。 实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等&gt;待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。 开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了。 死锁检测：一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。 CountDownLatch使用例子在这个例子中，我模拟了一个应用程序启动类，它开始时启动了n个线程类，这些线程将检查外部系统并通知闭锁，并且启动类一直在闭锁上等待着。一旦验证和检查了所有外部服务，那么启动类恢复执行。BaseHealthChecker.java：这个类是一个Runnable，负责所有特定的外部服务健康的检测。它删除了重复的代码和闭锁的中心控制代码。12345678910111213141516171819202122232425262728293031323334public abstract class BaseHealthChecker implements Runnable &#123; private CountDownLatch _latch; private String _serviceName; private boolean _serviceUp; //Get latch object in constructor so that after completing the task, thread can countDown() the latch public BaseHealthChecker(String serviceName, CountDownLatch latch) &#123; super(); this._latch = latch; this._serviceName = serviceName; this._serviceUp = false; &#125; @Override public void run() &#123; try &#123; verifyService(); _serviceUp = true; &#125; catch (Throwable t) &#123; t.printStackTrace(System.err); _serviceUp = false; &#125; finally &#123; if(_latch != null) &#123; _latch.countDown(); &#125; &#125; &#125; public String getServiceName() &#123; return _serviceName; &#125; public boolean isServiceUp() &#123; return _serviceUp; &#125; //This methos needs to be implemented by all specific service checker public abstract void verifyService();&#125; NetworkHealthChecker.java：这个类继承了BaseHealthChecker，实现了verifyService()方法。DatabaseHealthChecker.java和CacheHealthChecker.java除了服务名和休眠时间外&gt;，与NetworkHealthChecker.java是一样的。123456789101112131415public class NetworkHealthChecker extends BaseHealthChecker &#123; public NetworkHealthChecker (CountDownLatch latch) &#123; super("Network Service", latch); &#125; @Override public void verifyService() &#123; System.out.println("Checking " + this.getServiceName()); try &#123; Thread.sleep(7000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(this.getServiceName() + " is UP"); &#125;&#125; ApplicationStartupUtil.java：这个类是一个主启动类，它负责初始化闭锁，然后等待，直到所有服务都被检测完。1234567891011121314151617181920212223242526272829303132333435363738394041public class ApplicationStartupUtil &#123; //List of service checkers private static List&lt;BaseHealthChecker&gt; _services; //This latch will be used to wait on private static CountDownLatch _latch; private ApplicationStartupUtil() &#123; &#125; private final static ApplicationStartupUtil INSTANCE = new ApplicationStartupUtil(); public static ApplicationStartupUtil getInstance() &#123; return INSTANCE; &#125; public static boolean checkExternalServices() throws Exception &#123; //Initialize the latch with number of service checkers _latch = new CountDownLatch(3); //All add checker in lists _services = new ArrayList&lt;BaseHealthChecker&gt;(); _services.add(new NetworkHealthChecker(_latch)); _services.add(new CacheHealthChecker(_latch)); _services.add(new DatabaseHealthChecker(_latch)); //Start service checkers using executor framework Executor executor = Executors.newFixedThreadPool(_services.size()); for(final BaseHealthChecker v : _services) &#123; executor.execute(v); &#125; //Now wait till all services are checked _latch.await(); //Services are file and now proceed startup for(final BaseHealthChecker v : _services) &#123; if( ! v.isServiceUp()) &#123; return false; &#125; &#125; return true; &#125;&#125; 现在你可以写测试代码去检测一下闭锁的功能了。1234567891011public class Main &#123; public static void main(String[] args) &#123; boolean result = false; try &#123; result = ApplicationStartupUtil.checkExternalServices(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("External services validation completed !! Result was :: "+ result); &#125;&#125; Output in console: Checking Network ServiceChecking Cache ServiceChecking Database ServiceDatabase Service is UPCache Service is UPNetwork Service is UPExternal services validation completed !! Result was :: true 常见面试题可以为你的下次面试准备以下一些CountDownLatch相关的问题： 解释一下CountDownLatch概念? CountDownLatch 和CyclicBarrier的不同之处? 给出一些CountDownLatch使用的例子? CountDownLatch 类中主要的方法? 原文链接： howtodoinjava 翻译： ImportNew.com - 张涛译文链接： http://www.importnew.com/15731.html]]></content>
      <categories>
        <category>Core Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发之CountDownLatch、CyclicBarrier和Semaphore]]></title>
    <url>%2F2017%2F09%2F27%2FJava%E5%B9%B6%E5%8F%91%E4%B9%8BCountDownLatch%E3%80%81CyclicBarrier%E5%92%8CSemaphore%2F</url>
    <content type="text"><![CDATA[CountDownLatch 是能使一组线程等另一组线程都跑完了再继续跑；CyclicBarrier 能够使一组线程在一个时间点上达到同步，可以是一起开始执行全部任务或者一部分任务。 这次说一下 JUC 中的同步器三个主要的成员：CountDownLatch、CyclicBarrier 和 Semaphore（不知道有没有初学者觉得这三个的名字不太好记）。这三个是 JUC 中较为常用的同步器，通过它们可以方便地实现很多线程之间协作的功能。（下面的代码出自 JDK 文档） CountDownLatch直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。 作用CountDownLatch 的作用和 Thread.join() 方法类似，可用于一组线程和另外一组线程的协作。例如，主线程在做一项工作之前需要一系列的准备工作，只有这些准备工作都完成，主线程才能继续它的工作。这些准备工作彼此独立，所以可以并发执行以提高速度。在这个场景下就可以使用 CountDownLatch 协调线程之间的调度了。在直接创建线程的年代（Java 5.0 之前），我们可以使用 Thread.join()。在 JUC 出现后，因为线程池中的线程不能直接被引用，所以就必须使用 CountDownLatch 了。 示例下面的这个例子可以理解为 F1 赛车的维修过程，只有 startSignal （可以表示停车，可能名字不太贴合）命令下达之后，维修工才开始干活，只有等所有工人完成工作之后，赛车才能继续。12345678910111213141516171819202122232425262728class Driver &#123; // ... void main() throws InterruptedException &#123; CountDownLatch startSignal = new CountDownLatch(1); CountDownLatch doneSignal = new CountDownLatch(N); for (int i = 0; i &lt; N; ++i) // create and start threads new Thread(new Worker(startSignal, doneSignal)).start(); doSomethingElse(); // don't let run yet startSignal.countDown(); // let all threads proceed doSomethingElse(); doneSignal.await(); // wait for all to finish &#125; &#125; class Worker implements Runnable &#123; private final CountDownLatch startSignal; private final CountDownLatch doneSignal; Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123; this.startSignal = startSignal; this.doneSignal = doneSignal; &#125; public void run() &#123; try &#123; startSignal.await(); doWork(); doneSignal.countDown(); &#125; catch (InterruptedException ex) &#123;&#125; // return; &#125; void doWork() &#123; ... &#125; &#125; 当 startSignal.await() 会阻塞线程，当 startSignal.countDown() 被调用之后，所有 Worker 线程开始执行 doWork() 方法，所以 Worker。doWork() 是几乎同时开始执行的。当 Worker.doWork() 执行完毕后，调用 doneSignal.countDown()，在所有 Worker 线程执行完毕之后，主线程继续执行。 CyclicBarrierCyclicBarrier 翻译过来叫循环栅栏、循环障碍什么的（还是有点别扭的。所以还是别翻译了，只可意会不可言传啊）。它主要的方法就是一个：await()。await() 方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。在这之后，如果再次调用 await() 方法，计数就又会变成 N-1，新一轮重新开始，这便是 Cyclic 的含义所在。CyclicBarrier 的使用并不难，但需要主要它所相关的异常。除了常见的异常，CyclicBarrier.await() 方法会抛出一个独有的 BrokenBarrierException。这个异常发生在当某个线程在等待本 CyclicBarrier 时被中断或超时或被重置时，其它同样在这个 CyclicBarrier 上等待的线程便会受到 BrokenBarrierException。意思就是说，同志们，别等了，有个小伙伴已经挂了，咱们如果继续等有可能会一直等下去，所有各回各家吧。CyclicBarrier.await() 方法带有返回值，用来表示当前线程是第几个到达这个 Barrier 的线程。和 CountDownLatch 一样，CyclicBarrier 同样可以可以在构造函数中设定总计数值。与 CountDownLatch 不同的是，CyclicBarrier 的构造函数还可以接受一个 Runnable，会在 CyclicBarrier 被释放时执行。 “NOTE: CyclicBarrier 的功能也可以由 CountDownLatch 来实现 示例CyclicBarrier 的应用（当然，这个例子换成 CountDownLatch 也是可以实现的，很简单，就不说怎么写了）12345678910111213141516171819202122232425262728293031323334class Solver &#123; final int N; final float[][] data; final CyclicBarrier barrier; class Worker implements Runnable &#123; int myRow; Worker(int row) &#123; myRow = row; &#125; public void run() &#123; while (!done()) &#123; processRow(myRow); try &#123; barrier.await(); &#125; catch (InterruptedException ex) &#123; return; &#125; catch (BrokenBarrierException ex) &#123; return; &#125; &#125; &#125; &#125; public Solver(float[][] matrix) &#123; data = matrix; N = matrix.length; barrier = new CyclicBarrier(N, new Runnable() &#123; public void run() &#123; mergeRows(...); &#125; &#125;); for (int i = 0; i &lt; N; ++i) new Thread(new Worker(i)).start(); waitUntilDone(); &#125; &#125; CyclicBarrier 和 CountDownLatch 在用法上的不同CountDownLatch 适用于一组线程和另一个主线程之间的工作协作。一个主线程等待一组工作线程的任务完毕才继续它的执行是使用 CountDownLatch 的主要场景；CyclicBarrier 用于一组或几组线程，比如一组线程需要在一个时间点上达成一致，例如同时开始一个工作。另外，CyclicBarrier 的循环特性和构造函数所接受的 Runnable 参数也是 CountDownLatch 所不具备的。 SemaphoreSemaphore 直译是信号量，可能称它是许可量更容易理解。当然，因为在计算机科学中这个名字由来已久，所以不能乱改。它的功能比较好理解，就是通过构造函数设定一个数量的许可，然后通过 acquire 方法获得许可，release 方法释放许可。它还有 tryAcquire 和 acquireUninterruptibly 方法，可以根据自己的需要选择 示例：Semaphore 控制资源访问123456789101112131415161718192021222324252627282930313233343536class Pool &#123; private static final int MAX_AVAILABLE = 100; private final Semaphore available = new Semaphore(MAX_AVAILABLE, true); public Object getItem() throws InterruptedException &#123; available.acquire(); return getNextAvailableItem(); &#125; public void putItem(Object x) &#123; if (markAsUnused(x)) available.release(); &#125; // Not a particularly efficient data structure; just for demo protected Object[] items = ... whatever kinds of items being managed protected boolean[] used = new boolean[MAX_AVAILABLE]; protected synchronized Object getNextAvailableItem() &#123; for (int i = 0; i &lt; MAX_AVAILABLE; ++i) &#123; if (!used[i]) &#123; used[i] = true; return items[i]; &#125; &#125; return null; // not reached &#125; protected synchronized boolean markAsUnused(Object item) &#123; for (int i = 0; i &lt; MAX_AVAILABLE; ++i) &#123; if (item == items[i]) &#123; if (used[i]) &#123; used[i] = false; return true; &#125; else return false; &#125; &#125; return false; &#125; &#125; 上面这个示例中 Semaphore 的用法没什么可多讲的。需要留言的是这里面有两个同步方法，不过对吞吐应该没什么影响，因为主要是对一个 boolean 数组做一下 O(n) 的操作，而且每个循环里面的操作很简单，所以速度很快。不过不知道 JUC 里面线程池的控制是怎么做的，本人不才，还没看过那块源代码，得空看看，有知道的也可以说说。 最后一句话总结CountDownLatch 是能使一组线程等另一组线程都跑完了再继续跑；CyclicBarrier 能够使一组线程在一个时间点上达到同步，可以是一起开始执行全部任务或者一部分任务。同时，它是可以循环使用的；Semaphore 是只允许一定数量的线程同时执行一段任务。 原文链接：http://my.oschina.net/lifany/blog/207995]]></content>
      <categories>
        <category>Core Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
